<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE TemplateHaskell #-}</span><span>
</span><a name="line-2"></a><span class="hs-comment">-- | Generate @generics-sop@ boilerplate instances using Template Haskell.</span><span>
</span><a name="line-3"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">TH</span><span>
</span><a name="line-4"></a><span>  </span><span class="hs-special">(</span><span> </span><a href="Generics.SOP.TH.html#deriveGeneric"><span class="hs-identifier hs-var">deriveGeneric</span></a><span>
</span><a name="line-5"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Generics.SOP.TH.html#deriveGenericOnly"><span class="hs-identifier hs-var">deriveGenericOnly</span></a><span>
</span><a name="line-6"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Generics.SOP.TH.html#deriveGenericFunctions"><span class="hs-identifier hs-var">deriveGenericFunctions</span></a><span>
</span><a name="line-7"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Generics.SOP.TH.html#deriveMetadataValue"><span class="hs-identifier hs-var">deriveMetadataValue</span></a><span>
</span><a name="line-8"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Generics.SOP.TH.html#deriveMetadataType"><span class="hs-identifier hs-var">deriveMetadataType</span></a><span>
</span><a name="line-9"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-10"></a><span>
</span><a name="line-11"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">replicateM</span><span class="hs-special">)</span><span>
</span><a name="line-12"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fromMaybe</span><span class="hs-special">)</span><span>
</span><a name="line-13"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Proxy</span><span>
</span><a name="line-14"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Language</span><span class="hs-operator">.</span><span class="hs-identifier">Haskell</span><span class="hs-operator">.</span><span class="hs-identifier">TH</span><span>
</span><a name="line-15"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Language</span><span class="hs-operator">.</span><span class="hs-identifier">Haskell</span><span class="hs-operator">.</span><span class="hs-identifier">TH</span><span class="hs-operator">.</span><span class="hs-identifier">Syntax</span><span>
</span><a name="line-16"></a><span>
</span><a name="line-17"></a><span class="hs-keyword">import</span><span> </span><a href="Generics.SOP.BasicFunctors.html"><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">BasicFunctors</span></a><span>
</span><a name="line-18"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Generics.SOP.Metadata.html"><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">Metadata</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">SOP</span><span>
</span><a name="line-19"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Generics.SOP.Type.Metadata.html"><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Metadata</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">T</span><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span> </span><a href="Generics.SOP.NP.html"><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">NP</span></a><span>
</span><a name="line-21"></a><span class="hs-keyword">import</span><span> </span><a href="Generics.SOP.NS.html"><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">NS</span></a><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span> </span><a href="Generics.SOP.Universe.html"><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span class="hs-operator">.</span><span class="hs-identifier">Universe</span></a><span>
</span><a name="line-23"></a><span>
</span><a name="line-24"></a><span class="hs-comment">-- | Generate @generics-sop@ boilerplate for the given datatype.</span><span>
</span><a name="line-25"></a><span class="hs-comment">--</span><span>
</span><a name="line-26"></a><span class="hs-comment">-- This function takes the name of a datatype and generates:</span><span>
</span><a name="line-27"></a><span class="hs-comment">--</span><span>
</span><a name="line-28"></a><span class="hs-comment">--   * a 'Code' instance</span><span>
</span><a name="line-29"></a><span class="hs-comment">--   * a 'Generic' instance</span><span>
</span><a name="line-30"></a><span class="hs-comment">--   * a 'HasDatatypeInfo' instance</span><span>
</span><a name="line-31"></a><span class="hs-comment">--</span><span>
</span><a name="line-32"></a><span class="hs-comment">-- Note that the generated code will require the @TypeFamilies@ and</span><span>
</span><a name="line-33"></a><span class="hs-comment">-- @DataKinds@ extensions to be enabled for the module.</span><span>
</span><a name="line-34"></a><span class="hs-comment">--</span><span>
</span><a name="line-35"></a><span class="hs-comment">-- /Example:/ If you have the datatype</span><span>
</span><a name="line-36"></a><span class="hs-comment">--</span><span>
</span><a name="line-37"></a><span class="hs-comment">-- &gt; data Tree = Leaf Int | Node Tree Tree</span><span>
</span><a name="line-38"></a><span class="hs-comment">--</span><span>
</span><a name="line-39"></a><span class="hs-comment">-- and say</span><span>
</span><a name="line-40"></a><span class="hs-comment">--</span><span>
</span><a name="line-41"></a><span class="hs-comment">-- &gt; deriveGeneric ''Tree</span><span>
</span><a name="line-42"></a><span class="hs-comment">--</span><span>
</span><a name="line-43"></a><span class="hs-comment">-- then you get code that is equivalent to:</span><span>
</span><a name="line-44"></a><span class="hs-comment">--</span><span>
</span><a name="line-45"></a><span class="hs-comment">-- &gt; instance Generic Tree where</span><span>
</span><a name="line-46"></a><span class="hs-comment">-- &gt;</span><span>
</span><a name="line-47"></a><span class="hs-comment">-- &gt;   type Code Tree = '[ '[Int], '[Tree, Tree] ]</span><span>
</span><a name="line-48"></a><span class="hs-comment">-- &gt;</span><span>
</span><a name="line-49"></a><span class="hs-comment">-- &gt;   from (Leaf x)   = SOP (   Z (I x :* Nil))</span><span>
</span><a name="line-50"></a><span class="hs-comment">-- &gt;   from (Node l r) = SOP (S (Z (I l :* I r :* Nil)))</span><span>
</span><a name="line-51"></a><span class="hs-comment">-- &gt;</span><span>
</span><a name="line-52"></a><span class="hs-comment">-- &gt;   to (SOP    (Z (I x :* Nil)))         = Leaf x</span><span>
</span><a name="line-53"></a><span class="hs-comment">-- &gt;   to (SOP (S (Z (I l :* I r :* Nil)))) = Node l r</span><span>
</span><a name="line-54"></a><span class="hs-comment">-- &gt;   to _ = error &quot;unreachable&quot; -- to avoid GHC warnings</span><span>
</span><a name="line-55"></a><span class="hs-comment">-- &gt;</span><span>
</span><a name="line-56"></a><span class="hs-comment">-- &gt; instance HasDatatypeInfo Tree where</span><span>
</span><a name="line-57"></a><span class="hs-comment">-- &gt;   type DatatypeInfoOf Tree =</span><span>
</span><a name="line-58"></a><span class="hs-comment">-- &gt;     T.ADT &quot;Main&quot; &quot;Tree&quot;</span><span>
</span><a name="line-59"></a><span class="hs-comment">-- &gt;       '[ T.Constructor &quot;Leaf&quot;, T.Constructor &quot;Node&quot; ]</span><span>
</span><a name="line-60"></a><span class="hs-comment">-- &gt;</span><span>
</span><a name="line-61"></a><span class="hs-comment">-- &gt;   datatypeInfo _ =</span><span>
</span><a name="line-62"></a><span class="hs-comment">-- &gt;     T.demoteDatatypeInfo (Proxy :: Proxy (DatatypeInfoOf Tree))</span><span>
</span><a name="line-63"></a><span class="hs-comment">--</span><span>
</span><a name="line-64"></a><span class="hs-comment">-- /Limitations:/ Generation does not work for GADTs, for</span><span>
</span><a name="line-65"></a><span class="hs-comment">-- datatypes that involve existential quantification, for</span><span>
</span><a name="line-66"></a><span class="hs-comment">-- datatypes with unboxed fields.</span><span>
</span><a name="line-67"></a><span class="hs-comment">--</span><span>
</span><a name="line-68"></a><span class="hs-identifier">deriveGeneric</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Dec</span><span class="hs-special">]</span><span>
</span><a name="line-69"></a><a name="deriveGeneric"><a href="Generics.SOP.TH.html#deriveGeneric"><span class="hs-identifier">deriveGeneric</span></a></a><span> </span><a name="local-6989586621679177528"><a href="#local-6989586621679177528"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-70"></a><span>  </span><a name="local-6989586621679177529"><a href="#local-6989586621679177529"><span class="hs-identifier">dec</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Generics.SOP.TH.html#reifyDec"><span class="hs-identifier hs-var">reifyDec</span></a><span> </span><a href="#local-6989586621679177528"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-71"></a><span>  </span><a name="local-6989586621679177530"><a href="#local-6989586621679177530"><span class="hs-identifier">ds1</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Generics.SOP.TH.html#withDataDec"><span class="hs-identifier hs-var">withDataDec</span></a><span> </span><a href="#local-6989586621679177529"><span class="hs-identifier hs-var">dec</span></a><span> </span><a href="Generics.SOP.TH.html#deriveGenericForDataDec"><span class="hs-identifier hs-var">deriveGenericForDataDec</span></a><span>
</span><a name="line-72"></a><span>  </span><a name="local-6989586621679177531"><a href="#local-6989586621679177531"><span class="hs-identifier">ds2</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Generics.SOP.TH.html#withDataDec"><span class="hs-identifier hs-var">withDataDec</span></a><span> </span><a href="#local-6989586621679177529"><span class="hs-identifier hs-var">dec</span></a><span> </span><a href="Generics.SOP.TH.html#deriveMetadataForDataDec"><span class="hs-identifier hs-var">deriveMetadataForDataDec</span></a><span>
</span><a name="line-73"></a><span>  </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679177530"><span class="hs-identifier hs-var">ds1</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="#local-6989586621679177531"><span class="hs-identifier hs-var">ds2</span></a><span class="hs-special">)</span><span>
</span><a name="line-74"></a><span>
</span><a name="line-75"></a><span class="hs-comment">-- | Like 'deriveGeneric', but omit the 'HasDatatypeInfo' instance.</span><span>
</span><a name="line-76"></a><span class="hs-identifier">deriveGenericOnly</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Dec</span><span class="hs-special">]</span><span>
</span><a name="line-77"></a><a name="deriveGenericOnly"><a href="Generics.SOP.TH.html#deriveGenericOnly"><span class="hs-identifier">deriveGenericOnly</span></a></a><span> </span><a name="local-6989586621679177532"><a href="#local-6989586621679177532"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-78"></a><span>  </span><a name="local-6989586621679177533"><a href="#local-6989586621679177533"><span class="hs-identifier">dec</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Generics.SOP.TH.html#reifyDec"><span class="hs-identifier hs-var">reifyDec</span></a><span> </span><a href="#local-6989586621679177532"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-79"></a><span>  </span><a href="Generics.SOP.TH.html#withDataDec"><span class="hs-identifier hs-var">withDataDec</span></a><span> </span><a href="#local-6989586621679177533"><span class="hs-identifier hs-var">dec</span></a><span> </span><a href="Generics.SOP.TH.html#deriveGenericForDataDec"><span class="hs-identifier hs-var">deriveGenericForDataDec</span></a><span>
</span><a name="line-80"></a><span>
</span><a name="line-81"></a><span class="hs-comment">-- | Like 'deriveGenericOnly', but don't derive class instance, only functions.</span><span>
</span><a name="line-82"></a><span class="hs-comment">--</span><span>
</span><a name="line-83"></a><span class="hs-comment">-- /Example:/ If you say</span><span>
</span><a name="line-84"></a><span class="hs-comment">--</span><span>
</span><a name="line-85"></a><span class="hs-comment">-- &gt; deriveGenericFunctions ''Tree &quot;TreeCode&quot; &quot;fromTree&quot; &quot;toTree&quot;</span><span>
</span><a name="line-86"></a><span class="hs-comment">--</span><span>
</span><a name="line-87"></a><span class="hs-comment">-- then you get code that is equivalent to:</span><span>
</span><a name="line-88"></a><span class="hs-comment">--</span><span>
</span><a name="line-89"></a><span class="hs-comment">-- &gt; type TreeCode = '[ '[Int], '[Tree, Tree] ]</span><span>
</span><a name="line-90"></a><span class="hs-comment">-- &gt;</span><span>
</span><a name="line-91"></a><span class="hs-comment">-- &gt; fromTree :: Tree -&gt; SOP I TreeCode</span><span>
</span><a name="line-92"></a><span class="hs-comment">-- &gt; fromTree (Leaf x)   = SOP (   Z (I x :* Nil))</span><span>
</span><a name="line-93"></a><span class="hs-comment">-- &gt; fromTree (Node l r) = SOP (S (Z (I l :* I r :* Nil)))</span><span>
</span><a name="line-94"></a><span class="hs-comment">-- &gt;</span><span>
</span><a name="line-95"></a><span class="hs-comment">-- &gt; toTree :: SOP I TreeCode -&gt; Tree</span><span>
</span><a name="line-96"></a><span class="hs-comment">-- &gt; toTree (SOP    (Z (I x :* Nil)))         = Leaf x</span><span>
</span><a name="line-97"></a><span class="hs-comment">-- &gt; toTree (SOP (S (Z (I l :* I r :* Nil)))) = Node l r</span><span>
</span><a name="line-98"></a><span class="hs-comment">-- &gt; toTree _ = error &quot;unreachable&quot; -- to avoid GHC warnings</span><span>
</span><a name="line-99"></a><span class="hs-comment">--</span><span>
</span><a name="line-100"></a><span class="hs-comment">-- @since 0.2</span><span>
</span><a name="line-101"></a><span class="hs-comment">--</span><span>
</span><a name="line-102"></a><span class="hs-identifier">deriveGenericFunctions</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Dec</span><span class="hs-special">]</span><span>
</span><a name="line-103"></a><a name="deriveGenericFunctions"><a href="Generics.SOP.TH.html#deriveGenericFunctions"><span class="hs-identifier">deriveGenericFunctions</span></a></a><span> </span><a name="local-6989586621679177534"><a href="#local-6989586621679177534"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679177535"><a href="#local-6989586621679177535"><span class="hs-identifier">codeName</span></a></a><span> </span><a name="local-6989586621679177536"><a href="#local-6989586621679177536"><span class="hs-identifier">fromName</span></a></a><span> </span><a name="local-6989586621679177537"><a href="#local-6989586621679177537"><span class="hs-identifier">toName</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-104"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679177538"><a href="#local-6989586621679177538"><span class="hs-identifier">codeName'</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkName</span><span> </span><a href="#local-6989586621679177535"><span class="hs-identifier hs-var">codeName</span></a><span>
</span><a name="line-105"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679177539"><a href="#local-6989586621679177539"><span class="hs-identifier">fromName'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkName</span><span> </span><a href="#local-6989586621679177536"><span class="hs-identifier hs-var">fromName</span></a><span>
</span><a name="line-106"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679177540"><a href="#local-6989586621679177540"><span class="hs-identifier">toName'</span></a></a><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkName</span><span> </span><a href="#local-6989586621679177537"><span class="hs-identifier hs-var">toName</span></a><span>
</span><a name="line-107"></a><span>  </span><a name="local-6989586621679177541"><a href="#local-6989586621679177541"><span class="hs-identifier">dec</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Generics.SOP.TH.html#reifyDec"><span class="hs-identifier hs-var">reifyDec</span></a><span> </span><a href="#local-6989586621679177534"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-108"></a><span>  </span><a href="Generics.SOP.TH.html#withDataDec"><span class="hs-identifier hs-var">withDataDec</span></a><span> </span><a href="#local-6989586621679177541"><span class="hs-identifier hs-var">dec</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679177542"><a href="#local-6989586621679177542"><span class="hs-identifier">_isNewtype</span></a></a><span> </span><a name="local-6989586621679177543"><a href="#local-6989586621679177543"><span class="hs-identifier">_cxt</span></a></a><span> </span><a name="local-6989586621679177544"><a href="#local-6989586621679177544"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679177545"><a href="#local-6989586621679177545"><span class="hs-identifier">_bndrs</span></a></a><span> </span><a name="local-6989586621679177546"><a href="#local-6989586621679177546"><span class="hs-identifier">cons</span></a></a><span> </span><a name="local-6989586621679177547"><a href="#local-6989586621679177547"><span class="hs-identifier">_derivs</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-109"></a><span>    </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679177548"><a href="#local-6989586621679177548"><span class="hs-identifier">codeType</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Generics.SOP.TH.html#codeFor"><span class="hs-identifier hs-var">codeFor</span></a><span> </span><a href="#local-6989586621679177546"><span class="hs-identifier hs-var">cons</span></a><span>                        </span><span class="hs-comment">-- '[ '[Int], '[Tree, Tree] ]</span><span>
</span><a name="line-110"></a><span>    </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679177549"><a href="#local-6989586621679177549"><span class="hs-identifier">repType</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">t</span><span class="hs-glyph">|</span><span> </span><a href="Generics.SOP.NS.html#SOP"><span class="hs-identifier hs-type">SOP</span></a><span> </span><a href="Generics.SOP.BasicFunctors.html#I"><span class="hs-identifier hs-type">I</span></a><span> </span><span class="hs-operator">$</span><span class="hs-special">(</span><span class="hs-identifier hs-var">conT</span><span> </span><a href="#local-6989586621679177538"><span class="hs-identifier hs-var">codeName'</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span class="hs-special">]</span><span>       </span><span class="hs-comment">-- SOP I TreeCode</span><span>
</span><a name="line-111"></a><span>    </span><span class="hs-identifier hs-var">sequence</span><span>
</span><a name="line-112"></a><span>      </span><span class="hs-special">[</span><span> </span><span class="hs-identifier hs-var">tySynD</span><span> </span><a href="#local-6989586621679177538"><span class="hs-identifier hs-var">codeName'</span></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><a href="#local-6989586621679177548"><span class="hs-identifier hs-var">codeType</span></a><span>                    </span><span class="hs-comment">-- type TreeCode = '[ '[Int], '[Tree, Tree] ]</span><span>
</span><a name="line-113"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">sigD</span><span> </span><a href="#local-6989586621679177539"><span class="hs-identifier hs-var">fromName'</span></a><span> </span><span class="hs-special">[</span><span class="hs-identifier">t</span><span class="hs-glyph">|</span><span> </span><span class="hs-operator">$</span><span class="hs-special">(</span><span class="hs-identifier hs-var">conT</span><span> </span><a href="#local-6989586621679177544"><span class="hs-identifier hs-var">name</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679177549"><span class="hs-operator hs-var">$</span><span class="hs-identifier hs-var">repType</span></a><span> </span><span class="hs-glyph">|</span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- fromTree :: Tree -&gt; SOP I TreeCode</span><span>
</span><a name="line-114"></a><span>      </span><span class="hs-special">,</span><span> </span><a href="Generics.SOP.TH.html#embedding"><span class="hs-identifier hs-var">embedding</span></a><span> </span><a href="#local-6989586621679177539"><span class="hs-identifier hs-var">fromName'</span></a><span> </span><a href="#local-6989586621679177546"><span class="hs-identifier hs-var">cons</span></a><span>                        </span><span class="hs-comment">-- fromTree ... =</span><span>
</span><a name="line-115"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">sigD</span><span> </span><a href="#local-6989586621679177540"><span class="hs-identifier hs-var">toName'</span></a><span> </span><span class="hs-special">[</span><span class="hs-identifier">t</span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679177549"><span class="hs-operator hs-var">$</span><span class="hs-identifier hs-var">repType</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-operator">$</span><span class="hs-special">(</span><span class="hs-identifier hs-var">conT</span><span> </span><a href="#local-6989586621679177544"><span class="hs-identifier hs-var">name</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span class="hs-special">]</span><span>    </span><span class="hs-comment">-- toTree :: SOP I TreeCode -&gt; Tree</span><span>
</span><a name="line-116"></a><span>      </span><span class="hs-special">,</span><span> </span><a href="Generics.SOP.TH.html#projection"><span class="hs-identifier hs-var">projection</span></a><span> </span><a href="#local-6989586621679177540"><span class="hs-identifier hs-var">toName'</span></a><span> </span><a href="#local-6989586621679177546"><span class="hs-identifier hs-var">cons</span></a><span>                         </span><span class="hs-comment">-- toTree ... =</span><span>
</span><a name="line-117"></a><span>      </span><span class="hs-special">]</span><span>
</span><a name="line-118"></a><span>
</span><a name="line-119"></a><span class="hs-comment">-- | Derive @DatatypeInfo@ value for the type.</span><span>
</span><a name="line-120"></a><span class="hs-comment">--</span><span>
</span><a name="line-121"></a><span class="hs-comment">-- /Example:/ If you say</span><span>
</span><a name="line-122"></a><span class="hs-comment">--</span><span>
</span><a name="line-123"></a><span class="hs-comment">-- &gt; deriveMetadataValue ''Tree &quot;TreeCode&quot; &quot;treeDatatypeInfo&quot;</span><span>
</span><a name="line-124"></a><span class="hs-comment">--</span><span>
</span><a name="line-125"></a><span class="hs-comment">-- then you get code that is equivalent to:</span><span>
</span><a name="line-126"></a><span class="hs-comment">--</span><span>
</span><a name="line-127"></a><span class="hs-comment">-- &gt; treeDatatypeInfo :: DatatypeInfo TreeCode</span><span>
</span><a name="line-128"></a><span class="hs-comment">-- &gt; treeDatatypeInfo = ADT &quot;Main&quot; &quot;Tree&quot;</span><span>
</span><a name="line-129"></a><span class="hs-comment">-- &gt;     (Constructor &quot;Leaf&quot; :* Constructor &quot;Node&quot; :* Nil)</span><span>
</span><a name="line-130"></a><span class="hs-comment">--</span><span>
</span><a name="line-131"></a><span class="hs-comment">-- /Note:/ CodeType need to be derived with 'deriveGenericFunctions'.</span><span>
</span><a name="line-132"></a><span class="hs-comment">--</span><span>
</span><a name="line-133"></a><span class="hs-comment">-- @since 0.2</span><span>
</span><a name="line-134"></a><span class="hs-comment">--</span><span>
</span><a name="line-135"></a><span class="hs-identifier">deriveMetadataValue</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Dec</span><span class="hs-special">]</span><span>
</span><a name="line-136"></a><a name="deriveMetadataValue"><a href="Generics.SOP.TH.html#deriveMetadataValue"><span class="hs-identifier">deriveMetadataValue</span></a></a><span> </span><a name="local-6989586621679178174"><a href="#local-6989586621679178174"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679178175"><a href="#local-6989586621679178175"><span class="hs-identifier">codeName</span></a></a><span> </span><a name="local-6989586621679178176"><a href="#local-6989586621679178176"><span class="hs-identifier">datatypeInfoName</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-137"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679178177"><a href="#local-6989586621679178177"><span class="hs-identifier">codeName'</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkName</span><span> </span><a href="#local-6989586621679178175"><span class="hs-identifier hs-var">codeName</span></a><span>
</span><a name="line-138"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679178178"><a href="#local-6989586621679178178"><span class="hs-identifier">datatypeInfoName'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkName</span><span> </span><a href="#local-6989586621679178176"><span class="hs-identifier hs-var">datatypeInfoName</span></a><span>
</span><a name="line-139"></a><span>  </span><a name="local-6989586621679178179"><a href="#local-6989586621679178179"><span class="hs-identifier">dec</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Generics.SOP.TH.html#reifyDec"><span class="hs-identifier hs-var">reifyDec</span></a><span> </span><a href="#local-6989586621679178174"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-140"></a><span>  </span><a href="Generics.SOP.TH.html#withDataDec"><span class="hs-identifier hs-var">withDataDec</span></a><span> </span><a href="#local-6989586621679178179"><span class="hs-identifier hs-var">dec</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679178180"><a href="#local-6989586621679178180"><span class="hs-identifier">isNewtype</span></a></a><span> </span><a name="local-6989586621679178181"><a href="#local-6989586621679178181"><span class="hs-identifier">_cxt</span></a></a><span> </span><a name="local-6989586621679178182"><a href="#local-6989586621679178182"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679178183"><a href="#local-6989586621679178183"><span class="hs-identifier">_bndrs</span></a></a><span> </span><a name="local-6989586621679178184"><a href="#local-6989586621679178184"><span class="hs-identifier">cons</span></a></a><span> </span><a name="local-6989586621679178185"><a href="#local-6989586621679178185"><span class="hs-identifier">_derivs</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-141"></a><span>    </span><span class="hs-identifier hs-var">sequence</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-identifier hs-var">sigD</span><span> </span><a href="#local-6989586621679178178"><span class="hs-identifier hs-var">datatypeInfoName'</span></a><span> </span><span class="hs-special">[</span><span class="hs-identifier">t</span><span class="hs-glyph">|</span><span> </span><a href="Generics.SOP.Metadata.html#DatatypeInfo"><span class="hs-identifier hs-type">SOP</span><span class="hs-operator hs-type">.</span><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-operator">$</span><span class="hs-special">(</span><span class="hs-identifier hs-var">conT</span><span> </span><a href="#local-6989586621679178177"><span class="hs-identifier hs-var">codeName'</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span class="hs-special">]</span><span>                    </span><span class="hs-comment">-- treeDatatypeInfo :: DatatypeInfo TreeCode</span><span>
</span><a name="line-142"></a><span>             </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">funD</span><span> </span><a href="#local-6989586621679178178"><span class="hs-identifier hs-var">datatypeInfoName'</span></a><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-var">clause</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">normalB</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Generics.SOP.TH.html#metadata%27"><span class="hs-identifier hs-var">metadata'</span></a><span> </span><a href="#local-6989586621679178180"><span class="hs-identifier hs-var">isNewtype</span></a><span> </span><a href="#local-6989586621679178182"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679178184"><span class="hs-identifier hs-var">cons</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- treeDatatypeInfo = ...</span><span>
</span><a name="line-143"></a><span>             </span><span class="hs-special">]</span><span>
</span><a name="line-144"></a><span class="hs-pragma">{-# DEPRECATED deriveMetadataValue &quot;Use 'deriveMetadataType' and 'demoteDatatypeInfo' instead.&quot; #-}</span><span>
</span><a name="line-145"></a><span>
</span><a name="line-146"></a><span class="hs-comment">-- | Derive @DatatypeInfo@ type for the type.</span><span>
</span><a name="line-147"></a><span class="hs-comment">--</span><span>
</span><a name="line-148"></a><span class="hs-comment">-- /Example:/ If you say</span><span>
</span><a name="line-149"></a><span class="hs-comment">--</span><span>
</span><a name="line-150"></a><span class="hs-comment">-- &gt; deriveMetadataType ''Tree &quot;TreeDatatypeInfo&quot;</span><span>
</span><a name="line-151"></a><span class="hs-comment">--</span><span>
</span><a name="line-152"></a><span class="hs-comment">-- then you get code that is equivalent to:</span><span>
</span><a name="line-153"></a><span class="hs-comment">--</span><span>
</span><a name="line-154"></a><span class="hs-comment">-- &gt; type TreeDatatypeInfo =</span><span>
</span><a name="line-155"></a><span class="hs-comment">-- &gt;   T.ADT &quot;Main&quot; &quot;Tree&quot;</span><span>
</span><a name="line-156"></a><span class="hs-comment">-- &gt;     [ T.Constructor &quot;Leaf&quot;, T.Constructor &quot;Node&quot; ]</span><span>
</span><a name="line-157"></a><span class="hs-comment">--</span><span>
</span><a name="line-158"></a><span class="hs-comment">-- @since 0.3.0.0</span><span>
</span><a name="line-159"></a><span class="hs-comment">--</span><span>
</span><a name="line-160"></a><span class="hs-identifier">deriveMetadataType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Dec</span><span class="hs-special">]</span><span>
</span><a name="line-161"></a><a name="deriveMetadataType"><a href="Generics.SOP.TH.html#deriveMetadataType"><span class="hs-identifier">deriveMetadataType</span></a></a><span> </span><a name="local-6989586621679178187"><a href="#local-6989586621679178187"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679178188"><a href="#local-6989586621679178188"><span class="hs-identifier">datatypeInfoName</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-162"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679178189"><a href="#local-6989586621679178189"><span class="hs-identifier">datatypeInfoName'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkName</span><span> </span><a href="#local-6989586621679178188"><span class="hs-identifier hs-var">datatypeInfoName</span></a><span>
</span><a name="line-163"></a><span>  </span><a name="local-6989586621679178190"><a href="#local-6989586621679178190"><span class="hs-identifier">dec</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Generics.SOP.TH.html#reifyDec"><span class="hs-identifier hs-var">reifyDec</span></a><span> </span><a href="#local-6989586621679178187"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-164"></a><span>  </span><a href="Generics.SOP.TH.html#withDataDec"><span class="hs-identifier hs-var">withDataDec</span></a><span> </span><a href="#local-6989586621679178190"><span class="hs-identifier hs-var">dec</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-glyph">\</span><span> </span><a name="local-6989586621679178191"><a href="#local-6989586621679178191"><span class="hs-identifier">isNewtype</span></a></a><span> </span><a name="local-6989586621679178192"><a href="#local-6989586621679178192"><span class="hs-identifier">_ctx</span></a></a><span> </span><a name="local-6989586621679178193"><a href="#local-6989586621679178193"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679178194"><a href="#local-6989586621679178194"><span class="hs-identifier">_bndrs</span></a></a><span> </span><a name="local-6989586621679178195"><a href="#local-6989586621679178195"><span class="hs-identifier">cons</span></a></a><span> </span><a name="local-6989586621679178196"><a href="#local-6989586621679178196"><span class="hs-identifier">_derivs</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-165"></a><span>    </span><span class="hs-identifier hs-var">sequence</span><span>
</span><a name="line-166"></a><span>      </span><span class="hs-special">[</span><span> </span><span class="hs-identifier hs-var">tySynD</span><span> </span><a href="#local-6989586621679178189"><span class="hs-identifier hs-var">datatypeInfoName'</span></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><a href="Generics.SOP.TH.html#metadataType%27"><span class="hs-identifier hs-var">metadataType'</span></a><span> </span><a href="#local-6989586621679178191"><span class="hs-identifier hs-var">isNewtype</span></a><span> </span><a href="#local-6989586621679178193"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679178195"><span class="hs-identifier hs-var">cons</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">]</span><span>
</span><a name="line-167"></a><span>
</span><a name="line-168"></a><span class="hs-identifier">deriveGenericForDataDec</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Bool</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Con</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Generics.SOP.TH.html#Derivings"><span class="hs-identifier hs-type">Derivings</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Dec</span><span class="hs-special">]</span><span>
</span><a name="line-169"></a><a name="deriveGenericForDataDec"><a href="Generics.SOP.TH.html#deriveGenericForDataDec"><span class="hs-identifier">deriveGenericForDataDec</span></a></a><span> </span><a name="local-6989586621679178197"><a href="#local-6989586621679178197"><span class="hs-identifier">_isNewtype</span></a></a><span> </span><a name="local-6989586621679178198"><a href="#local-6989586621679178198"><span class="hs-identifier">_cxt</span></a></a><span> </span><a name="local-6989586621679178199"><a href="#local-6989586621679178199"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679178200"><a href="#local-6989586621679178200"><span class="hs-identifier">bndrs</span></a></a><span> </span><a name="local-6989586621679178201"><a href="#local-6989586621679178201"><span class="hs-identifier">cons</span></a></a><span> </span><a name="local-6989586621679178202"><a href="#local-6989586621679178202"><span class="hs-identifier">_derivs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-170"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679178203"><a href="#local-6989586621679178203"><span class="hs-identifier">typ</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Generics.SOP.TH.html#appTyVars"><span class="hs-identifier hs-var">appTyVars</span></a><span> </span><a href="#local-6989586621679178199"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679178200"><span class="hs-identifier hs-var">bndrs</span></a><span>
</span><a name="line-171"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,9,0)</span><span>
</span><a name="line-172"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679178204"><a href="#local-6989586621679178204"><span class="hs-identifier">codeSyn</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">tySynInstD</span><span> </span><span class="hs-char">''Code $ tySynEqn [typ] (codeFor cons)
#else
  let codeSyn = tySynInstD ''Code [typ] (codeFor cons)
#endif
  inst &lt;- instanceD
            (cxt [])
            [t| Generic $typ |]
            [codeSyn, embedding 'from cons, projection 'to cons]
  return [inst]

deriveMetadataForDataDec :: Bool -&gt; Cxt -&gt; Name -&gt; [TyVarBndr] -&gt; [Con] -&gt; Derivings -&gt; Q [Dec]
deriveMetadataForDataDec isNewtype _cxt name bndrs cons _derivs = do
  let typ = appTyVars name bndrs
  md   &lt;- instanceD (cxt [])
            [t| HasDatatypeInfo $typ |]
            [ metadataType typ isNewtype name cons
            , funD 'datatypeInfo
                [ clause [wildP]
                  (normalB [| SOP.T.demoteDatatypeInfo (Proxy :: Proxy (DatatypeInfoOf $typ)) |])
                  []
                ]
            ]
            -- [metadata isNewtype name cons]
  return [md]


{-------------------------------------------------------------------------------
  Computing the code for a data type
-------------------------------------------------------------------------------}

codeFor :: [Con] -&gt; Q Type
codeFor = promotedTypeList . map go
  where
    go :: Con -&gt; Q Type
    go c = do (_, ts) &lt;- conInfo c
              promotedTypeList ts

{-------------------------------------------------------------------------------
  Computing the embedding/projection pair
-------------------------------------------------------------------------------}

embedding :: Name -&gt; [Con] -&gt; Q Dec
embedding fromName = funD fromName . go (\e -&gt; [| Z $e |])
  where
    go :: (Q Exp -&gt; Q Exp) -&gt; [Con] -&gt; [Q Clause]
    go _  []     = []
    go br (c:cs) = mkClause br c : go (\e -&gt; [| S $(br e) |]) cs

    mkClause :: (Q Exp -&gt; Q Exp) -&gt; Con -&gt; Q Clause
    mkClause br c = do
      (n, ts) &lt;- conInfo c
      vars    &lt;- replicateM (length ts) (newName &quot;x&quot;)
      clause [conP n (map varP vars)]
             (normalB [| SOP $(br . npE . map (appE (conE 'I) . varE) $ vars) |])
             []

projection :: Name -&gt; [Con] -&gt; Q Dec
projection toName = funD toName . go (\p -&gt; conP 'Z [p])
  where
    go :: (Q Pat -&gt; Q Pat) -&gt; [Con] -&gt; [Q Clause]
    go _ [] = [unreachable]
    go br (c:cs) = mkClause br c : go (\p -&gt; conP 'S [br p]) cs

    mkClause :: (Q Pat -&gt; Q Pat) -&gt; Con -&gt; Q Clause
    mkClause br c = do
      (n, ts) &lt;- conInfo c
      vars    &lt;- replicateM (length ts) (newName &quot;x&quot;)
      clause [conP 'SOP [br . npP . map (\v -&gt; conP 'I [varP v]) $ vars]]
             (normalB . appsE $ conE n : map varE vars)
             []

unreachable :: Q Clause
unreachable = clause [wildP]
                     (normalB [| error &quot;unreachable&quot; |])
                     []

{-------------------------------------------------------------------------------
  Compute metadata
-------------------------------------------------------------------------------}

metadataType :: Q Type -&gt; Bool -&gt; Name -&gt; [Con] -&gt; Q Dec
metadataType typ isNewtype typeName cs =
  tySynInstD ''DatatypeInfoOf (tySynEqn [typ] (metadataType' isNewtype typeName cs))

-- | Derive term-level metadata.
metadata' :: Bool -&gt; Name -&gt; [Con] -&gt; Q Exp
metadata' isNewtype typeName cs = md
  where
    md :: Q Exp
    md | isNewtype = [| SOP.Newtype $(stringE (nameModule' typeName))
                                    $(stringE (nameBase typeName))
                                    $(mdCon (head cs))
                      |]
       | otherwise = [| SOP.ADT     $(stringE (nameModule' typeName))
                                    $(stringE (nameBase typeName))
                                    $(npE $ map mdCon cs)
                      |]


    mdCon :: Con -&gt; Q Exp
    mdCon (NormalC n _)   = [| SOP.Constructor $(stringE (nameBase n)) |]
    mdCon (RecC n ts)     = [| SOP.Record      $(stringE (nameBase n))
                                               $(npE (map mdField ts))
                             |]
    mdCon (InfixC _ n _)  = do
#if MIN_VERSION_template_haskell(2,11,0)
      fixity &lt;- reifyFixity n
      case fromMaybe defaultFixity fixity of
        Fixity f a -&gt;
#else
      i &lt;- reify n
      case i of
        DataConI _ _ _ (Fixity f a) -&gt;
#endif
                            [| SOP.Infix       $(stringE (nameBase n)) $(mdAssociativity a) f |]
#if !MIN_VERSION_template_haskell(2,11,0)
        _                -&gt; fail &quot;Strange infix operator&quot;
#endif
    mdCon (ForallC _ _ _) = fail &quot;Existentials not supported&quot;
#if MIN_VERSION_template_haskell(2,11,0)
    mdCon (GadtC _ _ _)    = fail &quot;GADTs not supported&quot;
    mdCon (RecGadtC _ _ _) = fail &quot;GADTs not supported&quot;
#endif

    mdField :: VarStrictType -&gt; Q Exp
    mdField (n, _, _) = [| SOP.FieldInfo $(stringE (nameBase n)) |]

    mdAssociativity :: FixityDirection -&gt; Q Exp
    mdAssociativity InfixL = [| SOP.LeftAssociative  |]
    mdAssociativity InfixR = [| SOP.RightAssociative |]
    mdAssociativity InfixN = [| SOP.NotAssociative   |]

-- | Derive type-level metadata.
metadataType' :: Bool -&gt; Name -&gt; [Con] -&gt; Q Type
metadataType' isNewtype typeName cs = md
  where
    md :: Q Type
    md | isNewtype = [t| 'SOP.T.Newtype $(stringT (nameModule' typeName))
                                        $(stringT (nameBase typeName))
                                        $(mdCon (head cs))
                       |]
       | otherwise = [t| 'SOP.T.ADT     $(stringT (nameModule' typeName))
                                        $(stringT (nameBase typeName))
                                        $(promotedTypeList $ map mdCon cs)
                       |]


    mdCon :: Con -&gt; Q Type
    mdCon (NormalC n _)   = [t| 'SOP.T.Constructor $(stringT (nameBase n)) |]
    mdCon (RecC n ts)     = [t| 'SOP.T.Record      $(stringT (nameBase n))
                                                   $(promotedTypeList (map mdField ts))
                              |]
    mdCon (InfixC _ n _)  = do
#if MIN_VERSION_template_haskell(2,11,0)
      fixity &lt;- reifyFixity n
      case fromMaybe defaultFixity fixity of
        Fixity f a -&gt;
#else
      i &lt;- reify n
      case i of
        DataConI _ _ _ (Fixity f a) -&gt;
#endif
                            [t| 'SOP.T.Infix       $(stringT (nameBase n)) $(mdAssociativity a) $(natT f) |]
#if !MIN_VERSION_template_haskell(2,11,0)
        _                -&gt; fail &quot;Strange infix operator&quot;
#endif
    mdCon (ForallC _ _ _) = fail &quot;Existentials not supported&quot;
#if MIN_VERSION_template_haskell(2,11,0)
    mdCon (GadtC _ _ _)    = fail &quot;GADTs not supported&quot;
    mdCon (RecGadtC _ _ _) = fail &quot;GADTs not supported&quot;
#endif

    mdField :: VarStrictType -&gt; Q Type
    mdField (n, _, _) = [t| 'SOP.T.FieldInfo $(stringT (nameBase n)) |]

    mdAssociativity :: FixityDirection -&gt; Q Type
    mdAssociativity InfixL = [t| 'SOP.T.LeftAssociative  |]
    mdAssociativity InfixR = [t| 'SOP.T.RightAssociative |]
    mdAssociativity InfixN = [t| 'SOP.T.NotAssociative   |]

nameModule' :: Name -&gt; String
nameModule' = fromMaybe &quot;&quot; . nameModule

{-------------------------------------------------------------------------------
  Constructing n-ary pairs
-------------------------------------------------------------------------------}

-- Given
--
-- &gt; [a, b, c]
--
-- Construct
--
-- &gt; a :* b :* c :* Nil
npE :: [Q Exp] -&gt; Q Exp
npE []     = [| Nil |]
npE (e:es) = [| $e :* $(npE es) |]

-- Like npE, but construct a pattern instead
npP :: [Q Pat] -&gt; Q Pat
npP []     = conP 'Nil []
npP (p:ps) = conP '(:*) [p, npP ps]

{-------------------------------------------------------------------------------
  Some auxiliary definitions for working with TH
-------------------------------------------------------------------------------}

conInfo :: Con -&gt; Q (Name, [Q Type])
conInfo (NormalC n ts) = return (n, map (return . (\(_, t)    -&gt; t)) ts)
conInfo (RecC    n ts) = return (n, map (return . (\(_, _, t) -&gt; t)) ts)
conInfo (InfixC (_, t) n (_, t')) = return (n, map return [t, t'])
conInfo (ForallC _ _ _) = fail &quot;Existentials not supported&quot;
#if MIN_VERSION_template_haskell(2,11,0)
conInfo (GadtC _ _ _)    = fail &quot;GADTs not supported&quot;
conInfo (RecGadtC _ _ _) = fail &quot;GADTs not supported&quot;
#endif

stringT :: String -&gt; Q Type
stringT = litT . strTyLit

natT :: Int -&gt; Q Type
natT = litT . numTyLit . fromIntegral

promotedTypeList :: [Q Type] -&gt; Q Type
promotedTypeList []     = promotedNilT
promotedTypeList (t:ts) = [t| $promotedConsT $t $(promotedTypeList ts) |]

appTyVars :: Name -&gt; [TyVarBndr] -&gt; Q Type
appTyVars n = go (conT n)
  where
    go :: Q Type -&gt; [TyVarBndr] -&gt; Q Type
    go t []                  = t
    go t (PlainTV  v   : vs) = go [t| $t $(varT v) |] vs
    go t (KindedTV v _ : vs) = go [t| $t $(varT v) |] vs

reifyDec :: Name -&gt; Q Dec
reifyDec name =
  do info &lt;- reify name
     case info of TyConI dec -&gt; return dec
                  _          -&gt; fail &quot;Info must be type declaration type.&quot;

withDataDec :: Dec -&gt; (Bool -&gt; Cxt -&gt; Name -&gt; [TyVarBndr] -&gt; [Con] -&gt; Derivings -&gt; Q a) -&gt; Q a
#if MIN_VERSION_template_haskell(2,11,0)
withDataDec (DataD    ctxt name bndrs _ cons derivs) f = f False ctxt name bndrs cons  derivs
withDataDec (NewtypeD ctxt name bndrs _ con  derivs) f = f True  ctxt name bndrs [con] derivs
#else
withDataDec (DataD    ctxt name bndrs cons derivs) f = f False ctxt name bndrs cons  derivs
withDataDec (NewtypeD ctxt name bndrs con  derivs) f = f True  ctxt name bndrs [con] derivs
#endif
withDataDec _ _ = fail &quot;Can only derive labels for datatypes and newtypes.&quot;

-- | Utility type synonym to cover changes in the TH code
#if MIN_VERSION_template_haskell(2,12,0)
type Derivings = [DerivClause]
#elif MIN_VERSION_template_haskell(2,11,0)
type Derivings = Cxt
#else
type Derivings = [Name]
#endif
</span></pre></body></html>